<?xml version="1.0" encoding='ISO-8859-1'?>
<!-- ยง{{header}}: -->
<!-- Mork Compiler Tool, -->
<!-- Copyright (c) 1998-2003  Michael Hartmeier -->
<!-- Mork is licensed under the terms of the GNU Lesser General Public License. -->
<!-- It is distributed in the hope that it will be useful, but WITHOUT ANY -->
<!-- WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS -->
<!-- FOR A PARTICULAR PURPOSE. See the file license.txt for details. -->
<!-- ยง. -->

<chapter>
<title>Mapper files</title>

<formalpara>
<title>Mapping</title>
<para>Turning input streams into objects is called <emphasis>mapping</emphasis>
<indexterm significance="preferred"><primary>mapping</primary></indexterm>. Mapping turns data from
a character representation into an object representation. Initially, data is represented as a
sequence of characters without structure. This representation is appropriate to edit, store or
transfer data. In contrast, the object representation the input stream is mapped to is appropriate
to process the data. For example, numbers are represented by <literal>int</literal>s and list are
represented by <literal>List</literal> objects. The purpose of mapping is to turn input streams into
the representation most appropriate to process the data. Note: the object representation is similar
to abstract syntax trees generated by some compiler tools, but the classes underlying individual
objects can be freely chosen and objects are not restricted to trees. </para></formalpara>

<figure>
<title>Mapping</title>
<mediaobject>
<imageobject>
<imagedata fileref="mapping.jpg" format="JPG"/>
</imageobject>
</mediaobject>
</figure>

<formalpara>
<title>Steps</title>
<para>Mapping is comprised of two steps. In step one, the input stream is syntactically analyzed.
This includes scanning and parsing and results in a syntax tree. This step turns that input
stream from a character representation into a tree representation. The tree representation is
used because it's most appropriate to check the syntax of the input stream. Step two takes the
syntax tree and maps it into objects. This step computed attributes and includes semantic
analysis like identifier resolution and type checking. </para></formalpara>

<formalpara>
<title>Mapper</title>
<para>Mapping is performed by an mapper object. A mapper is invoked for an input stream, performs
scanning, parsing and semantic analysis and returns the objects resulting from the last step.
A mapper is similar to an <literal>ObjectInputStream</literal>, they both kind of de-serializes
objects and they are both objects themselves. However, a mapper de-serializes from a human-readable
stream, whereas an <literal>ObjectInputStream</literal> de-serialize from an machine-readable stream.
</para></formalpara>

<formalpara>
<title>Mapper files</title>
<para>A mapper file is a text file that defines a mapper.
<indexterm significance="preferred"><primary>mapping</primary></indexterm>It defines the syntax of
an input stream by referencing a syntax file and it defines how to map syntax trees into objects.
Mork translates mapper files into Java classes. </para></formalpara>

<formalpara>
<title>Naming conventions</title>
<para>Mork does not restrict the name of mapper files. My naming convention for mapper files is
as follows. The base name is <literal>Mapper</literal> if an application needs a single mapper
only. Otherwise, the name of the syntax is preprended, starting with a capital letter. The file
name extension is <literal>.map</literal> (all lower case on every platform). Example 1: Each of
Mork's example applications has a single mapper only. Consequently, all example mapper file have
the <literal>Mapper.map</literal>. Example 2: Mork itself has three mappers:
<literal>GrammarMapper</literal>, <literal>MapperMapper</literal> and
<literal>DtdMapper.map</literal>. They map grammar files, mapper files and dtd files. Note:
mapper file names should start with a capital letter because their are translated into Java class
files, and the naming convention for classes is to start with a capital letter.
</para></formalpara>

<formalpara>
<title>Outline</title>
<para>This chapter is about mapper files. Its sections are structured along the main entities of
mapper files. A section typically starts with a formal syntax specification, followed by an
informal description of the respective entity. Sections try to be complete, even if forward
references are necessary. Note: the full syntax specification for mapper files is given in the
appendix, the formal syntax specification at the start of a section are taken from this appendix.
</para></formalpara>

<formalpara>
<title>Lexical structure</title>
<para>Grammar files and mapper files have the same lexical structure. A description was given
in the previous chapter, it's not repeated here.</para></formalpara>


<formalpara>
<title>Meta</title>
<para>In some sense, syntax files as described in the previous chapter are simple because
there is nothing special compared to other compiler tools. Defining mapper files should also be
simple because it is basically a simple association. However, this chapter probably turns out to
be more difficult because (1) the mapping concept differs from other tools and thus needs
more explanations and (2) this chapter of the manual is incomplete. </para></formalpara>


<sect1>
<title>Overall structure</title>

<figure>
<title>Overall structure</title>
<programlisting>
Mapper              ::= MapperName SyntaxFile Imports Definitions ;
MapperName          ::= "mapper" Name ";" ;
SyntaxFile          ::= Grammar | Dtd ;
Grammar             ::= "grm" "=" StringLiteral ";" ;
Dtd                 ::= "dtd" "=" StringLiteral ";" ;
Imports             ::= Import* ;
Import              ::= "import" PackageName ":" Class ("," Class)* ";";
Class               ::= Identifier ("->" Identifier)? ;
PackageName         ::= Name ;
Name                ::= Identifier ("." Identifier)* ;
</programlisting>
</figure>

<formalpara>
<title>Overview</title>
<para>Start symbol of the mapper file grammar is <literal>Mapper</literal>.
<literal>Definitions</literal> form the core of mapper files, they associates symbols
defined in <literal>SyntaxFile</literal> with Java classes declared in
<literal>Imports</literal>.</para></formalpara>

<sect2>
<title>Mapper name</title>

<formalpara>
<title>Purpose</title>
<para>The mapper name specifies a fully qualified name for the mapper. The name has to
follow Java's rules for fully qualified class names. When generating a mapper, the name is used
as a prefix for the various classes resulting from the generation. When running an application,
the mapper name is used to locate and load these classes. The name is fully qualified, i.e. the
mapper package is always included. Thus, the mapper name is like Java package declaration combined
with a class definition combined into a single statement. </para></formalpara>

<formalpara>
<title>File names vs. class names</title>
<para>Java distinguishes class names and file names (for class files): A class name is
not necessarily the name of the class file with the byte code for this class. For example,
you can define a (non-public) Java class <literal>Foo</literal> in a Java file
<literal>Bar.java</literal>. The Java compiler will generate a file <literal>Bar.class</literal>
which defines a class <literal>Foo</literal>. Mork implements the same behavior for mappers:
Defining a mapper <literal>Foo</literal> in a mapper file <literal>Bar.map</literal> results
in a Java class file <literal>Foo.class</literal> defining a class <literal>Bar</literal>.
</para></formalpara>

</sect2>

<sect2>
<title>Syntax file</title>

<formalpara>
<title>Syntax File</title>
<para><literal>SyntaxFile</literal> refers to the file defining the mapper's syntax.
<literal>StringLiteral</literal> is the file name. A relative file name is interpreted
relative to the location of the mapper file, not relative to the current directory.
The character separating directories in the file name is <literal>/</literal>, regardless of
the platform you run Mork on. Thus, it is illegal to use backslashes on Windows. Rationale:
make mapper file platform independent.</para></formalpara>

</sect2>

<sect2>
<title>Import declarations</title>

<formalpara>
<title>Purpose</title>
<para><literal>Imports</literal> resemble Java import declarations: Import declarations specify
classes to be referenced by simple identifiers, without the package that contains the class. The
purpose of both Java and Mork import declarations is to simplify references to classes with long
qualified names. Qualified names can get quite long, especially because Java naming conventions
suggest a unique vendor name as part of the package name.</para></formalpara>

<formalpara>
<title>Imported classes</title>
<para>An import declaration <literal>import p:X -> Y;</literal> (where <literal>p</literal> is a
package name and <literal>X</literal> is a simple identifier) declares the imported class
<literal>Y</literal>. The imported class <literal>Y</literal> is a reference to the class
<literal>p.X</literal>. <literal>import p:X;</literal> is equivalent to
<literal>import p:X -> X;</literal>.</para></formalpara>

<formalpara>
<title>Restrictions</title>
<para>To import a class, the following conditions have to be met:
<itemizedlist>
  <listitem><para>There is exactly one imported class <literal>Y</literal>.
    </para></listitem>
  <listitem><para><literal>p.X</literal> has been properly compiled and is available
    on the <literal>CLASSPATH</literal>.</para></listitem>
  <listitem><para><literal>p.X</literal> is a class. It is an error to import primitive
    types or interface types.</para></listitem>
  <listitem><para><literal>p.X</literal> is a public; it must not have private or
    default (i.e. package) visibility.</para></listitem>
  <listitem><para>Classes in unnamed packages are not supported. To
    import a class, it has to be member of a package.</para></listitem>
  <listitem><para>Nested classes are not supported, only top-level classes
    may be imported.</para></listitem>
</itemizedlist></para></formalpara>

<formalpara>
<title>Document dependencies</title>
<para>The purpose of Mork import declarations goes beyond Java's import declarations: they are
meant to document all dependencies of a mapper file. To realize this, mapper files allows to
reference classes by simple identifiers only, qualified names are not allowed. Thus it is
impossible to reference a class without mentioning the class in an import declaration.
</para></formalpara>

<formalpara>
<title>No import on demand</title>
<para>In contrast to Java, <literal>import *</literal> - aka import on demand - is not
supported. E.g. Mork rejects <literal>import java.util.*</literal>). Rationale for this
restriction: document dependencies, every class used in a mapper file has to be declared
explicitly by an import declaration. To reduce the typing resulting from this strategy,
you can import multiple classes from the same package without repeating the package name.
</para></formalpara>

<formalpara>
<title>No implicit imports</title>
<para>Mork has nothing like Java's implicit <literal>import java.lang.*</literal>.
Thus, Mork requires an <literal>import java.lang: Integer</literal> before the
<literal>Integer</literal> class can be referenced. In addition, classes from the mapper's
package have to be explicitly imported. Example: <literal>import foo: Bar;</literal> is
required to reference <literal>foo.Bar</literal> even if the mapper package is
<literal>foo</literal>. Once again, the rationale is to document dependencies.
</para></formalpara>

</sect2>
</sect1>

<sect1>
<title>Constructors</title>

<figure>
<title>Constructors</title>
<programlisting>
Constructor         ::= ClassRef | MemberRef | Internal | Copy;
ClassRef            ::= Identifier ;
MemberRef           ::= Identifier "." Identifier ;
Internal            ::= "[" Identifier "]" ;
Copy                ::= "(" Identifier ")" ;
</programlisting>
</figure>

<formalpara>
<title>Definition</title>
<para>A constructor creates an object or throws an exception. A constructor is a generalization
of a Java constructor. It is either a normal constructor or a special constructor. A normal
constructor is a Java constructor or a Java member (i.e. methods or a fields). Thus, most Java
classes define a set of constructors. A Java constructor is referenced by its class, a
member constructor is referenced that a class and an identifier. Note that classes are referenced
by simple identifiers, qualified class names are not supported. (See the section about import
declarations for more details).  Besides normal constructors, Mork provides two kind of special
constructors: internal constructors and copy constructors.
</para></formalpara>

<formalpara>
<title>Unused constructors</title>
<para>A constructors is invoked even if the result is never used. This is useful if the constructors
has side-effects (maybe side-effects on arguments), and the return type is void or the result
is not used.</para></formalpara>

<para>A constructor is characterized by its:
<itemizedlist>
  <listitem><para>name</para></listitem>
  <listitem><para>argument type list</para></listitem>
  <listitem><para>result type</para></listitem>
  <listitem><para>exceptions</para></listitem>
</itemizedlist></para>

<formalpara>
<title>Static typing</title>
<para>Argument and return types are known at compile time. This type information is used by
Mork to perform static type checking. At runtime, all values passed to or returned from a
constructor are guarantied to be assignable to/from the specified type. It is impossible to
get runtime type mismatches here because of an illegal constructor invocation.</para></formalpara>

<sect2>
<title>Normal constructors</title>

<formalpara>
<title>Java constructors</title>
<para><itemizedlist>
  <listitem><formalpara><title>name</title>
    <para>A public Java constructor of an imported class <literal>C</literal> defines a
    constructor with the name <literal>C</literal>.</para></formalpara></listitem>
  <listitem><formalpara><title>arguments</title>
    <para><literal>C</literal> takes the same arguments as the Java constructor.
    </para></formalpara></listitem>
  <listitem><formalpara><title>result</title>
    <para><literal>C</literal> returns the object created by the Java constructor.
    </para></formalpara></listitem>
  <listitem><formalpara><title>exceptions</title>
    <para><literal>C</literal> throws all exceptions (both checked and unchecked)
    thrown by the Java constructor.</para></formalpara></listitem>
</itemizedlist></para></formalpara>

<formalpara>
<title>Java methods</title>
<para><itemizedlist>
  <listitem><formalpara><title>name</title>
    <para>A public Java method <literal>m</literal> of an imported class <literal>C</literal>
    defines a constructor with the name <literal>C.m</literal>.
    </para></formalpara></listitem>
  <listitem><formalpara><title>arguments</title>
    <para><literal>C.m</literal> takes the same arguments as the Java method; non-static
    methods take an additional argument of type C as the first argument.
    </para></formalpara></listitem>
  <listitem><formalpara><title>result</title>
    <para><literal>C.m</literal> returns the result of the Java method call. For non-static
    methods the constructor invokes the Java method on the object passed as first argument.
    </para></formalpara></listitem>
  <listitem><formalpara><title>exceptions</title>
    <para><literal>C.m</literal> throws all exceptions (both checked and unchecked)
    thrown by <literal>C.m</literal>.</para></formalpara></listitem>
</itemizedlist></para></formalpara>

<formalpara>
<title>Java fields</title>
<para><itemizedlist>
  <listitem><formalpara><title>name</title>
    <para>A public Java field <literal>F</literal> of a imported class <literal>C</literal>
    defines a constructor <literal>C.F</literal>.</para></formalpara></listitem>
  <listitem><formalpara><title>arguments</title>
    <para>If <literal>C.F</literal> is a static field, <literal>C.F</literal> takes no
    arguments. Otherwise, <literal>C.F</literal> takes an argument of type <literal>C</literal>.
    </para></formalpara></listitem>
  <listitem><formalpara><title>result</title>
    <para>If <literal>C.F</literal> is a static field, <literal>C.F</literal> returns the
    value of the static field. Otherwise, <literal>C.F</literal> returns the value of the field
    of the argument object.</para></formalpara></listitem>
  <listitem><formalpara><title>exceptions</title>
    <para>C.F throws a <literal>NullPointerException</literal> is a non-static field is invoked
    with a null argument.</para></formalpara></listitem>
</itemizedlist></para></formalpara>

<formalpara>
<title>Example</title>
<para>TODO</para></formalpara>

</sect2>

<sect2>
<title>Special constructors</title>

<formalpara>
<title>Internal constructors</title>
<para>Internal constructors provide access to internal variables maintained by
the scanner. Only terminal symbols can use internal constructors, it is an error
to trigger an internal constructor for a non-terminal symbol. Internal constructors
are specified within array brackets. The following list shows the available
internal constructors, what the constructor returns and the return type. None of
these constructors takes arguments and none of these constructors throws exceptions.
</para></formalpara>

<itemizedlist>
<listitem><formalpara><title>text</title>
  <para>Returns a string object with the characters of the current terminal
  symbol. For example, <literal>42</literal> might be the text returned for an
  <literal>Integer</literal> terminal symbol. Return type is String.</para>
  </formalpara></listitem>
<listitem><formalpara><title><literal>ofs</literal></title>
  <para>Returns an Integer value with the current source offset. The first
   offset is 0. Return type is Integer.</para></formalpara></listitem>
<listitem><formalpara><title>line</title>
  <para>Returns an Integer value with the current source line. The first
  line is 1. Return type is Integer.</para></formalpara></listitem>
<listitem><formalpara><title>column</title>
  <para>Returns an Integer value with the current source column. The first
  column is 1. Return type is Integer.</para></formalpara></listitem>
</itemizedlist>

<formalpara>
<title>Copy constructors</title>
<para>A copy constructor is specified by a class name within brackets.
The specified name must be the simple name of a class imported in the
section header. This notation resembles the Java cast operator. The copy
constructor does nothing, in particular, no constructor is invoked. Copy
constructors are useful to work around some argument passing problems.
Copy constructors should become obsolete by solving these problems.
</para></formalpara>

</sect2>

<sect2>
<title>Exceptions</title>

<formalpara>
<title>Purpose</title>
<para>Constructors may throw checked and unchecked exceptions. An unchecked exception
is an exception derived from <literal>java.lang.RuntimeException</literal> or
<literal>java.lang.Error</literal>). Otherwise, it is a checked exception. Technically,
a constructor may throw exceptions of any type, whenever it sees fit; there are no
restrictions imposed by Mork. However, I suggest using exceptions as outlines in the
section.</para></formalpara>

<sect3>
<title>Unchecked exceptions</title>

<para>Unchecked exceptions should be thrown if a constructor detects an internal error.
An internal error is something that "should not happen", an inconsistent/unexpected state.
An internal error can be avoided by the programmer. If not, it's a bug. A
<literal>NullPointerException</literal> usually indicate an internal error. </para>

<formalpara>
<title>Example</title>
<para><literal>java.lang.Integer.parseInt</literal> throws the unchecked exception
<literal>NumberFormatException</literal>. If the mapper syntax imposes the correct
number syntax on the strings passed to <literal>parseInt</literal>, the method can be
used as a constructor. If a <literal>NumberFormatException</literal> occurs, this is a
bug in the application, because the string passed to <literal>parseInt</literal> is
assumed to be a valid number.</para></formalpara>

</sect3>

<sect3>
<title>Checked exceptions</title>

<formalpara>
<title>Usage</title>
<para>A constructor should use checked exceptions to impose constraints on the input.
Whenever the input (i.e. the arguments passed to the constructors) violates a constraint,
a checked exception should be thrown. You are free to check whatever constraint you wish.
A mapper catches checked exceptions and turns the exception's message into an error
message. Typically, this message is show to the end-user.</para></formalpara>

<formalpara>
<title>Semantic errors</title>
<para>Compiler text books use the term semantic error if some constraint on the input
stream has been violated. The classic semantic errors are "undefined identifiers" and
"type mismatches". </para></formalpara>

<formalpara>
<title>Example 1</title>
<para><literal>java.lang.Class.forName</literal> throws the checked exception
<literal>ClassNotFoundException</literal>. When used as a constructor, this is reported
as a semantic error. </para></formalpara>

<formalpara>
<title>Example 2</title>
<para>Consider a calculator and an end-user entering the term <literal>1/0</literal>. The
<literal>div</literal> method below issues the appropriate error message by throwing
a <literal>GenericException</literal>. (<literal>GenericException</literal> is a
general-purpose checked exception provided by Mork.) Without testing for 0 in the method
body, the <literal>1/0</literal> would result in an internal error of the calculator because
<literal>left/right</literal> would triggers the (unchecked!) exception
<literal>ArithmeticException</literal> if <literal>right == 0</literal>.
<programlisting>
package foo;

import de.mlhartme.mork.util.GenericException;

public class bar {
    public static int div(int left, int right) throws GenericException {
        if (right == 0) {
            throw new GenericException("division by zero");
        }
        return left/right;
    }
}
</programlisting>
</para></formalpara>

<formalpara>
<title>Note</title>
<para>Imposing constrains on constructor arguments sounds like Java's
<literal>IllegalArgumentExceptions</literal>. This exception usually indicates an internal
error: some Java code has invoked a constructor with illegal arguments. In contrast, a semantic
error is a checked exception, it is not considered an internal error. The difference to an
<literal>IllegalArgumentException</literal> is, that applications cannot prevent semantic errors:
arguments are attributes, and attributes stem (directly or indirectly) from end-user's input.
Unlike Java code, end-user input cannot be controlled by the application. </para></formalpara>

</sect3>

</sect2>

</sect1>

<sect1>
<title>Attributes</title>

<formalpara>
<title>Overview</title>
<para>An attribute associates a symbols with a constructor. A simple attribute is defined
by <literal>Foo => Bar</literal>, where <literal>Foo</literal> is a symbol and
<literal>Bar</literal> is the name of a constructor. Basically, a mapper file is a list of
attribute definitions, attributes form the core of the file, </para></formalpara>

<figure>
<title>Attribute syntax</title>
<programlisting>
Definitions         ::= Group* ;
Group               ::= Symbol Attribute+ ;
Symbol              ::= StringSymbol | IdentifierSymbol ;
StringSymbol        ::= StringLiteral ;
IdentifierSymbol    ::= Identifier ;
Attribute           ::= AttributeName "=>" Constructor Visibility;
AttributeName       ::= (":" Identifier)? ;
</programlisting>
</figure>

<sect2>
<title>Definition</title>

<formalpara>
<title>Attribute</title>
<para>An attribute is defined by (1) a symbol, (2) an attribute name, (3) a constructor
name and (4) visibility. The attribute is said to be attached to its symbol. Symbol and
constructor name are most important here, they define the actual mapping. In contrast, it's
common not to specify an <literal>AttributeName</literal> and a <literal>Visibility</literal>.
The constructor name (<literal>Constructor</literal>) may be overloaded. For example, a
constructor name <literal>foo</literal> might refer to a constructor
<literal>foo(String)</literal> and <literal>foo(List)</literal>.</para></formalpara>

<formalpara>
<title>Attribute groups</title>
<para>Attributes attached to the same symbol may be grouped. This is for your convenience,
the effect is the same as to isolated attribute definitions.</para></formalpara>

<formalpara>
<title>Attribute name</title>
<para><literal>AttributeName</literal> defines a name that can be used to refer to the
attribute in visibility declarations. Every attribute has a name, if it is not supplied
in the attribute definition, the name defaults to the name of the symbol the attribute is
attached to. Attribute names have to be unique throughout a mapper file.</para></formalpara>

<formalpara>
<title>Main attributes</title>
<para>A main attribute is an attribute whose name equals the name of the symbol it is
attached to. Since attribute names have to be unique, a given symbol has at most one
main attribute. Main attributes play a key role in defining implicit visibility.
</para></formalpara>

<formalpara>
<title>Visibility</title>
<para><literal>Visibility</literal> defines constructors where the attribute is passed as
an argument.</para></formalpara>

<formalpara>
<title>Argument passing</title>
<para>The argument list passed to a constructor is defined by the visibility of all attributes
defined in a mapper file. This differs from the Java mechanism where arguments are specified
explicitly by an argument list. </para></formalpara>

</sect2>

<sect2>
<title>Compile-time</title>

<para>At compile-time, Mork computes various values for each attribute: the type,
the argument list, and the constructor.</para>

<formalpara>
<title>Type</title>
<para>Objects are guaranteed to be of the attribute type. Attribute type is a Java type.
The type of an attribute is used to perform static type checking and to resolve overloaded
constructor names. In this sense, the attribute type is similar to the type of a local variable
in Java. However, the attribute type is not explicitly declared: The type <literal>t</literal>
of an attribute with constructor name <literal>N</literal> is computed as follows:<orderedlist>
  <listitem><para>Determine the list <literal>C</literal> of all constructors with name
    <literal>N</literal>. In may cases, <literal>C</literal> has a single element
    only. Otherwise, <literal>N</literal> is overloaded.</para></listitem>
  <listitem><para>Determine the list <literal>T</literal> of all return types of the
    constructors in <literal>C</literal>.</para></listitem>
  <listitem><para>Replace all primitive types in <literal>T</literal> by the
    corresponding wrapper type. For example, replaced <literal>int</literal>
    by <literal>Integer</literal>.</para></listitem>
  <listitem><para>The attribute type <literal>t</literal> is the most special Java
    class type that is assignable from each element in <literal>T</literal>.
    </para></listitem>
</orderedlist>
Notes:
(1) The attribute type is always a reference type, the above steps never
result in a primitive type. (2) The attribute type is always a class type,
the above steps never result in an interface type. Interface types had to be
excluded because they would introduce ambiguities to the algorithm.
</para></formalpara>

<formalpara>
<title>Example</title>
<para>Consider the attribute <literal>X => a;</literal> and two constructors
<literal>String a(String)</literal> and <literal>int a(int)</literal>. The attribute type is
<literal>Object</literal>, because Object is the common supertype of <literal>String</literal>
and <literal>Integer</literal>.</para></formalpara>

<formalpara>
<title>Argument list</title>
<para>The argument list is a list of attributes with cardinality. The visibility
section describes how the argument list is computed. TODO</para></formalpara>

<formalpara>
<title>Attribute constructor</title>
<para>An attribute's constructor is obtained by using the argument list to resolve overloaded
constructor names: A constructor name is resolved to a constructor <literal>F</literal> if the
argument list can be converted to the constructor's argument list. It is an error if there is
no such <literal>F</literal> or if <literal>F</literal> is not unique. This is the same mechanism
used in Java, the argument type decides, if the constructor name is ambiguous.
Note that overloading is resolved at compile-time, using static type information. It's not
possible to choose the constructor at runtime, using the actual argument type(s).
</para></formalpara>

<formalpara>
<title>Argument list conversion</title>
<para>Argument list conversion adjusts an argument list to match the formal argument list of
the attribute constructor. Conversion re-orders and unwrap arguments if necessary. The
conversion algorithm takes a list of actual arguments and transforms it to a list of converted
arguments:
<itemizedlist>
  <listitem><para>Choose the first formal argument F of the constructor.
    </para></listitem>
  <listitem><para>Choose the leftmost argument A from the actual argument
    list such that A can be converted to F.</para></listitem>
  <listitem><para>If no such A is found, the actual argument list cannot
    be converted. Otherwise, remove A from the actual argument list an
    append the converted type for A to the converted argument list.
    </para></listitem>
  <listitem><para>Repeat the previous steps for all remaining formal
    arguments.</para></listitem>
  <listitem><para>Conversion is succeeds, if all actual arguments have been
    moved to the converted arguments.</para></listitem>
</itemizedlist>Argument conversion is explained in the visibility
section.</para></formalpara>

<formalpara>
<title>Argument order</title>
<para>A given symbol may have any number of attributes. The ordering of objects
resulting at runtime follows the ordering of attribute definitions in the mapper file.
This implies that the array returned from running a mapper is ordered according the
attribute sequence for the start symbol.</para></formalpara>

</sect2>

<sect2>
<title>Runtime</title>

<formalpara>
<title>Runtime vs compile-time</title>
<para>Symbols and attributes are compile-time entities. They define how to create their
respective runtime entity: syntax tree nodes and objects. Each syntax tree node has a
defining symbol, and each object has a defining constructor.</para></formalpara>

<formalpara>
<title>Runtime effect</title>
<para>A syntax tree node for a given symbol <literal>S</literal> is mapped into objects by
invoking the constructors of all attributes attached to <literal>S</literal>. Example: an
attribute <literal>Foo => Bar;</literal> defines that the symbol <literal>Foo</literal> is
mapped to the object returned by the constructor <literal>Bar</literal>. Whenever a mapper
identifies a <literal>Foo</literal> syntax tree node, the <literal>Bar</literal> constructor
is invoked. The constructor returns an object which is passes to other constructors as
defined by the attributes visibility.</para></formalpara>

<formalpara>
<title>Runtime effect</title>
<para>At runtime, syntax tree nodes are mapped into objects. Consider a symbol
<literal>S</literal>. At runtime, each syntax tree node of <literal>S</literal> is
augmented with the objects that result from invoking all constructors
triggered for symbol. </para></formalpara>

<formalpara>
<title>Wrapper objects</title>
<para>If a constructor returns a primitive value, this is automatically wrapped by the
appropriate wrapper object. This wrapping is reflected in the above rules to compute the
attribute type. For example, <literal>int</literal> values are wrapped by
<literal>Integer</literal> objects. Automatic wrapping corresponds with automatic
unwrapping for constructor arguments. In effect, wrapping and unwrapping is transparent
for constructor definitions. Within Java code, you can freely choose to work with primitive
values or wrapper values. </para></formalpara>

</sect2>
</sect1>

<sect1>
<title>Visibility</title>

<para>Mork uses visibilities rules because most of the argument passing is trivial and known
implicitly. Visibility rules just specify where trivial argument passing does not apply.
</para>

<para>TODO: This section is a collection of fragments.
Visibility is very experimental and subject to change.</para>

<figure>
<title>Visibility syntax</title>
<programlisting>
Visibility          ::= Implicit | Explicit ;
Implicit            ::= ";" ;
Explicit            ::= ":" (">" Path)* ";" ;
</programlisting>
</figure>

<para>
Visibility defines to what constructor an object is passed as an argument.
It is specified by modifiers and a list of views. Most argument
passing is specified by modifiers, paths deals with special situations.
</para>

<formalpara>
<title>Empty visibility</title>
<para>The constructor of an attribute is invoked, even if it has an empty explicit visibility.
Empty explicit visibility is useful if the constructor has side-effects on its arguments.
</para></formalpara>

<formalpara>
<title>Argument types and argument values</title>
<para>An argument type is not the same as a Java type, because an argument
value is not (always) the same as a Java value! In fact, any number of Java
values might make up a single argument value. In many cases, an argument
value is comprised of exactly one Java value. However, argument values
can consist of a list of objects. In order to encode this, the argument type
is comprised of two elements: a component type and a cardinality.
</para></formalpara>

<formalpara>
<title>Component type</title>
<para>The component type is a Java reference type, for example String or
Object. Each individual Java value within an argument value is assignable
to the component type. Note that the component type can not be a Java
primitive type like int or boolean. This is not a restriction because Mork
automatically uses wrapper classes. Note also, that reference types include
both arrays of primitive types and arrays of reference types. The Java
language defines arrays to be reference types.</para></formalpara>

<formalpara>
<title>Cardinality</title>
<para>The cardinality determines how many Java values make up an
argument value. </para></formalpara>

<itemizedlist>
<listitem><formalpara><title>value</title>
  <para>Exactly one Java value. In this manual, C:1 denotes an argument
  type with component type C and value cardinality.</para></formalpara>
  </listitem>
<listitem><formalpara><title>option</title>
  <para>None or one Java value. In this manual, C:? denotes an argument
  type with component type C and option cardinality.</para></formalpara>
  </listitem>
<listitem><formalpara><title>sequence</title>
  <para>Any number of Java values, including zero. In this manual, C:*
  denotes an argument type with component type C and sequence cardinality.
  </para></formalpara></listitem>
</itemizedlist>

<formalpara>
<title>Conversion</title>
<para>Mappers pass argument values around, but constructors are defined
by Java programs and operate on Java objects. Constructors take Java values
as arguments and they return Java values as results. Thus, a mapper has
to convert between attribute values and Java values when transferring values
to and from constructors. The rules for these conversions are described in
the constructors section. </para></formalpara>

<formalpara>
<title>Argument conversion</title>
<para>Arguments are passed to constructors, which includes argument conversion.
At runtime, argument conversion might unwrap objects and create arrays
or lists. An argument A can be converted to a formal argument F if:
<itemizedlist>
<listitem>
  <para>A has value or option cardinality and F is assignable from the
  component type of A.</para></listitem>
<listitem>
  <para>A has value or option cardinality and F is a primitive type
  and the wrapper type for F is assignable from the component type of A.
  </para></listitem>
<listitem>
  <para>A has sequence cardinality and F is a assignable from a Java List
  or F is assignable from the array type for the component type.</para>
  </listitem>
</itemizedlist>
</para></formalpara>

<sect2>
<title>Paths</title>

<para>TODO: this section is a collection of fragments. Paths are still evolving and
subject to change.</para>

<formalpara>
<title>Purpose</title>
<para>Paths declare non-local visibility. They are special in two ways:
(1) a single path can select multiple values, and (2) paths can access
remote values.</para></formalpara>

<figure>
<title>Path syntax</title>
<programlisting>
Path                ::= ImplicitPath | LocalPath | NormalPath ;
ImplicitPath        ::= "\\\\*" ;
LocalPath           ::= Identifier ;
NormalPath          ::= Step+ ;
Step                ::= Move Identifier ;
Move                ::= Ups | Up | Downs | Down ;
Ups                 ::= "\\\\" ;
Up                  ::= "\\" ;
Downs               ::= "//" ;
Down                ::= "/" ;
</programlisting>
</figure>

<formalpara>
<title>Paths</title>
<para>A path is a sequence of steps, where a step is comprised of a move
and an identifier. The last identifier within a path is specifies an
attribute, all other identifiers specify symbols. The context of a path
is the attribute symbol, the path is used in.</para></formalpara>

<formalpara>
<title>Move</title>
<para>Move specify how to move in the syntax tree. Up and down moves
(<literal>\</literal> and <literal>/</literal>) specify a single step, ups and
downs moves (<literal>\\</literal> and <literal>//</literal>) specify repeated steps.
</para></formalpara>

<formalpara>
<title>Dead-end paths</title>
<para>A dead-end path is a path that does not reach any attributes, i.e. that does
not actually contribute to the visibility. <indexterm><primary>dead-end path</primary></indexterm>
It is an error to specify dead-end paths. Example: <literal>/X</literal> if a dead-end path when
applied to a symbol <literal>Y ::= Z Z; </literal>. TODO: what about the start symbols?
</para></formalpara>

</sect2>

</sect1>

</chapter>
