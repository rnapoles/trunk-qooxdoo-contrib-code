/* ************************************************************************

   License:
     LGPL: http://www.gnu.org/licenses/lgpl.html

   Authors:
     saaj <mail@saaj.me>

   Based on MDragAndDropSupport mixin by Christian Boulanger for 0.7.x branch

************************************************************************ */
/**
 * Provides drag&drop to TreeVirtual
 */
qx.Class.define("treevirtualdd.DragDropTree", {

	extend : qx.ui.treevirtual.TreeVirtual,

  construct : function(headings, custom)
  {
  	this._patchCodebase();

  	custom = !custom ? {} : custom;
  	custom.tablePaneHeader = function(obj)
    {
      /*
       * This is workaround for disabling draggable tree column.
       * Also i could not override it by setting Scroller
       * obj is tablePaneScroller
       */
      var stub                   = function () {};
      obj._onChangeCaptureHeader = stub;
      obj._onMousemoveHeader     = stub;
      obj._onMousedownHeader     = stub;
      obj._onMouseupHeader       = stub;
      obj._onClickHeader         = stub;

      return new qx.ui.table.pane.Header(obj);
    };

    this.base(arguments, headings, custom);

    this._createIndicator();

    this.setDraggable(true);
    this.setDroppable(true);

    this.setAllowDragTypes(["*"]);
    //this.setAllowDropTypes(["*"]);

    this.setEnableDragDrop(true);
  },

  properties : {

  	/**
     * enable/disable drag and drop
     * This needs to be the last property set since it configures
     * the drag and drop behavior based on the other properties
     */
    enableDragDrop :
    {
      check : "Boolean",
      apply : "_applyEnableDragDrop",
      init  : false
    },

    /**
     * a list of node types allowed to be dragged
     */
    allowDragTypes :
    {
      check    :  "Array",
      nullable : true,
      init     : null
    },

    /**
     * drag action(s). If you supply an array, multiple drag actions will be added
     */
    dragAction :
    {
      nullable : false,
      init     : "move"
    },

    /**
     * the number of milliseconds between scrolling up a row if drag cursor
     * is on the first row or scrolling down if drag cursor is on last row
     * during a drag session. You can turn off this behaviour by setting this
     * property to null.
     **/
    autoScrollInterval :
    {
      check    :  "Number",
      nullable : true,
      init     : 100
    },

    /**
     * whether it is possible to drop between nodes (i.e., for reordering them).
     * the focus indicator changed to a line to mark where the insertion should take place
     **/
    allowDropBetweenNodes :
    {
      check : "Boolean",
      init  : true
    },

    /**
     * array of two-element arrays containing a combination of drag source and
     * drop target types. Type information is in the nodeTypeProperty of the
     * userData hash map. If null, allow any combination. "*" can be used to as a
     * wildcard, i.e. [ ['Foo','*'] ...] will allow the 'Foo' type node to be dropped on any
     * other type, and [ ['*','Bar'] ...] will allow any type to be dropped on a 'Bar' type node.
     * The array ['*'] will allow any combination, null will deny any drop.
     **/
    allowDropTypes :
    {
      check    : "Array",
      nullable : true,
      init     : null
    },

    /**
     * records the target node on which the drag objects has been dropped
     **/
    dropTarget :
    {
      check    : "Object",
      nullable : true,
      init     : null
    },

    /**
     * provide a hint on where the node has been dropped
     * (-1 = above the node, 0 = on the node, 1 = below the node)
     **/
    dropTargetRelativePosition :
    {
      check : [-1, 0, 1],
      init  : 0
    }

  },

  members : {

  	_indicator : null,


  	_patchCodebase : function()
  	{
      qx.Class.include(qx.ui.treevirtual.TreeVirtual, qx.ui.treevirtual.MNode);

      // eliminate deprication message, its not for me ;)
      if(qx.core.Variant.isSet("qx.debug", "on"))
      {
        qx.ui.table.selection.Model.prototype._clearSelection = function()
        {
          this._resetSelection();
        };
        qx.ui.table.selection.Model.prototype.clearSelection = function()
        {
          this.resetSelection();
        };
      }

      // have not found official way to set validness check for events within widget
      qx.event.handler.DragDrop.prototype.setValidDrop = function(value)
      {
        this.__validDrop = !!value;
      };

      // sanitize the api access required
      qx.ui.table.pane.Scroller.prototype.getPaneClipper = function()
      {
        return this.__paneClipper;
      };
      qx.ui.table.pane.Scroller.prototype.getRowForPagePos = function(pageX, pageY)
      {
        return this._getRowForPagePos(pageX, pageY);
      };
  	},

  	_createIndicator : function()
  	{
      this._indicator = new qx.ui.core.Widget();
      this._indicator.set({
        decorator  : new qx.ui.decoration.Single().set({top : [2, "solid", "#333"]}),
        zIndex     : 100,
        droppable  : true
      });
      this._hideIndicator();

      this._getPaneClipper().add(this._indicator);
  	},

  	_hideIndicator : function()
  	{
      this._indicator.setOpacity(0);
  	},

  	_showIndicator : function()
  	{
      this._indicator.setOpacity(0.5);
  	},

  	_getDragDetails : function(dragEvent)
  	{
      // pane scroller widget takes care of mouse events
      var scroller = this.getTreePaneScroller();

      // calculate row and mouse Y position within row
      var paneClipperElem = this._getPaneClipper().getContentElement().getDomElement();
      var paneClipperTopY = qx.bom.element.Location.get(paneClipperElem, "box").top;
      var rowHeight       = scroller.getTable().getRowHeight();
      var scrollY         = scroller.getScrollY();
      if(scroller.getTable().getKeepFirstVisibleRowComplete())
      {
        scrollY = Math.floor(scrollY / rowHeight) * rowHeight;
      }

      var tableY = scrollY + dragEvent.getDocumentTop() - paneClipperTopY;
      var row    = Math.floor(tableY / rowHeight);
      var deltaY = tableY % rowHeight;

      // calculate relative row position in table
      var firstRow    = scroller.getChildControl("pane").getFirstVisibleRow();
      var rowCount    = scroller.getChildControl("pane").getVisibleRowCount();
      var lastRow     = firstRow + rowCount;
      var scrollY     = parseInt(scroller.getScrollY());
      var topDelta    = row - firstRow;
      var bottomDelta = lastRow - row;


      return {
        rowHeight   : rowHeight,
        row         : row,
        deltaY      : deltaY,
        firstRow    : firstRow,
        topDelta    : topDelta,
        bottomDelta : bottomDelta
      };
  	},

  	_checkDroppable : function(sourceData, dropTargetRelativePosition, dragDetails)
  	{
      if(!sourceData)
      {
        // we do not have any compatible datatype
        return false;
      }

      // use only the first node to determine node type
      var sourceNode = sourceData.nodeData[0];
      if(!sourceNode)
      {
        // no node to drag
        return false;
      }

      var sourceWidget = sourceData.sourceWidget;

      // get and save drag target
      var targetWidget  = this;
      var targetRowData = this.getDataModel().getRowData(dragDetails.row);
      if(!targetRowData)
      {
        return false;
      }

      var targetNode = targetRowData[0];
      if(!targetNode)
      {
        return false;
      }

      var targetParentNode = this.nodeGet(targetNode.parentNodeId);
      this.setDropTarget(targetNode);
      this.setDropTargetRelativePosition(dropTargetRelativePosition);

      // if we are dragging within the same widget
      if(sourceWidget == targetWidget)
      {
        // prevent drop of nodes on themself
        if(sourceNode.nodeId == targetNode.nodeId)
        {
          return false;
        }

        // prevent drop of parents on children
        var traverseNode = targetNode;
        while(traverseNode.parentNodeId)
        {
          if(traverseNode.parentNodeId == sourceNode.nodeId)
          {
            return false;
          }
          traverseNode = this.nodeGet(traverseNode.parentNodeId);
        }
      }

      // check legitimate source and target type combinations
      var sourceType     = this.getNodeDragType(sourceNode);
      var targetTypeNode = (dropTargetRelativePosition != 0) ? targetParentNode : targetNode;
      var targetType     = this.getNodeDragType(targetTypeNode);

      if(!targetType)
      {
        return false;
      }

      if(dropTargetRelativePosition != 0 && sourceNode.parentNodeId == targetNode.parentNodeId)
      {
        return true;
      }

      var allowDropTypes = this.getAllowDropTypes();

      if(!allowDropTypes)
      {
      	return false;
      }

      if(allowDropTypes[0] == "*")
      {
      	return true;
      }

      // check more closely
      for(var i = 0; i < allowDropTypes.length; i++)
      {
        if(
          (allowDropTypes[i][0] == sourceType || allowDropTypes[i][0] == "*") &&
          (allowDropTypes[i][1] == targetType || allowDropTypes[i][1] == "*" )
        )
        {
          return true;
        }
      }

      // do not allow any drop
      return false;
  	},

  	_processAutoscroll : function(dragDetails)
  	{
      var interval = this.getAutoScrollInterval();
      var details  = dragDetails;

      if(interval)
      {
      	var scroller = this.getTreePaneScroller();

        if(!this.__scrollFunctionId && (details.topDelta > -1 && details.topDelta < 2) && details.row != 0)
        {
          // scroll up if drag cursor at the top
          this.__scrollFunctionId = window.setInterval(function()
          {
            scroller.setScrollY(parseInt(scroller.getScrollY()) - details.rowHeight);
          }, interval);
        }
        else if(!this.__scrollFunctionId && (details.bottomDelta > 0 && details.bottomDelta < 3))
        {
          // scroll down if drag cursor is at the bottom
          this.__scrollFunctionId = window.setInterval(function()
          {
            scroller.setScrollY( parseInt(scroller.getScrollY()) + details.rowHeight);
          }, interval);
        }
        else if(this.__scrollFunctionId)
        {
          window.clearInterval(this.__scrollFunctionId);
          this.__scrollFunctionId = null;
        }
      }
  	},

  	_processDragInBetween : function(dragDetails)
  	{
      var result = 0;
      if(this.getAllowDropBetweenNodes())
      {
        if(dragDetails.deltaY < 4 || dragDetails.deltaY > (dragDetails.rowHeight - 4))
        {
          if(dragDetails.deltaY < 4)
          {
            this._indicator.setDomTop((dragDetails.row - dragDetails.firstRow) * dragDetails.rowHeight - 2);
            result = -1;
          }
          else
          {
            this._indicator.setDomTop((dragDetails.row - dragDetails.firstRow + 1 ) * dragDetails.rowHeight - 2);
            result = 1;
          }
          this._showIndicator();
        }
        else
        {
          this._indicator.setDomTop(-1000);
          this._hideIndicator();
        }
      }

      return result;
  	},

  	/**
     * enables or disables drag and drop, adds event listeners
     */
    _applyEnableDragDrop : function(value, old)
    {
      if(old && !value)
      {
        this.removeListener("dragstart", this.__onDragStart);
        this.removeListener("dragend",   this.__onDragEnd);
        this.removeListener("dragover",  this.__onDrag);
        this.removeListener("drag",      this.__onDrag);
      }

      if(value && !old)
      {
        this.addListener("dragstart", this.__onDragStart, this);
        this.addListener("dragend",   this.__onDragEnd,   this);
        this.addListener("dragover",  this.__onDrag,      this);
        this.addListener("drag",      this.__onDrag,      this);
      }
    },

    /**
     * Handles event fired whem a drag session starts.
     * @param event {Object} the drag event fired
     */
    __onDragStart : function(event)
    {
      var scroller = this.getTreePaneScroller();
      var row      = scroller.getRowForPagePos(event.getDocumentLeft(), event.getDocumentTop());
      if(row < 0)
      {
        return event.preventDefault();
      }

      // stop if no node drag type
      if(!this.getNodeDragType(this.getDataModel().getNodeFromRow(row).nodeId))
      {
      	return event.preventDefault();
      }

      var selection = this.getDataModel().getSelectedNodes();
      var types     = this.getAllowDragTypes();

      if(types === null)
      {
      	return event.preventDefault();
      }

      if(types[0] != "*")
      {
        // check for allowed types for all of he selection, i.e. if one
        // doesn't match, drag is not allowed.
        for(var i = 0; i < selection.length; i++)
        {
          var type = null;
          try
          {
            type = selection[i].data.DragDrop.type;
          }
          catch(e) {}

          // type is not among the allowed types, do not allow drag
          if(types.indexOf(type) < 0)
          {
          	return event.preventDefault();
          }
        }
      }

      // prepare drag data
      var dragData = {
        'nodeData'     : selection,
        'sourceWidget' : this,
        'action'       : this.getDragAction()
      };

      event.addAction(this.getDragAction());
      event.setUserData("treevirtualnode", dragData);
    },

    /**
     * Handles the event fired when a drag session ends (with or without drop).
     * To replace this handler, define and add your custom event listener before you setEnableDragDrop(true).
     */
    __onDragEnd : function(event)
    {
    	if(this.getAllowDropBetweenNodes())
    	{
    	  this._hideIndicator();
    	}
    },

    /**
     * the main method of this mixin, providing a check on whether drop is allowed, displaying a
     * insertion cursor for drop-between-nodes
     * @param event {Object} the drag event fired
     */
    __onDrag : function(event)
    {
      var sourceData  = event.getUserData("treevirtualnode");
      var dragDetails = this._getDragDetails(event);

      this._processAutoscroll(dragDetails);
      var dropTargetRelativePosition = this._processDragInBetween(dragDetails);


      var valid = this._checkDroppable(sourceData, dropTargetRelativePosition, dragDetails);
      event.getManager().setValidDrop(valid);
      if(valid)
      {
        qx.ui.core.DragDropCursor.getInstance().setAction(event.getCurrentAction());
      }
      else
      {
      	qx.ui.core.DragDropCursor.getInstance().resetAction();
      }
      //this.debug([event.getType(), dropTargetRelativePosition, valid, sourceData.action]);
    },

    _getPaneClipper : function()
    {
    	return this.getTreePaneScroller().getPaneClipper();
    },

    /**
     * get tree column pane scroller widget
     */
    getTreePaneScroller : function()
    {
      return this._getPaneScrollerArr()[this.getDataModel().getTreeColumn()];
    },

    /**
     * gets information on the drag session after the drop has occurred
     * @param event {Object} the drag event fired
     * @return {Object} map with the following information:
     * {
     *  'nodeData' : an array of selected nodes in the source widget, i.e. those nodes which were dragged,
     *  'sourceWidget' : the source widget,
     *  'targetNode' : the node on which the data was dropped,
     *  'position' : the relative position of the drop action: -1 = above, 0=on, 1= below the node
     * }
     */
    getDropData : function(event)
    {
      var dragData = event.getUserData("treevirtualnode");
      return {
        'nodeData'     : dragData.nodeData,
        'sourceWidget' : dragData.sourceWidget,
        //don't use event.getCurrentAction() 'cause event looses action sometimes on dragchange event
        'action'       : dragData.action,
        'targetNode'   : this.getDropTarget(),
        'position'     : this.getDropTargetRelativePosition()
      };
    },

    /**
     * gets the (drag) type of a node
     * @param nodeReference {Object|Integer}
     * @return {Object} the user-supplied type of the node or null if not set
     */
    getNodeDragType : function (nodeReference)
    {
      try
      {
        if(typeof nodeReference == "object")
        {
          return nodeReference.data.DragDrop.type;
        }
        else
        {
          return this.nodeGet(nodeReference).data.DragDrop.type;
        }
      }
      catch(e)
      {
        return null;
      }
    },

    /**
     * sets the (drag) type of a node
     * @param nodeReference {Object|Integer}
     * @param type {String}
     */
    setNodeDragType : function (nodeReference,type)
    {
      if(typeof type != "string")
      {
        this.error("Drag Type must be a string, got " + (typeof type));
      }

      var node = this.nodeGet(nodeReference);
      if(!node.data)
      {
        node.data = {};
      }
      if(!node.data.DragDrop)
      {
        node.data.DragDrop = {};
      }

      node.data.DragDrop.type = type;
    }

  }

});