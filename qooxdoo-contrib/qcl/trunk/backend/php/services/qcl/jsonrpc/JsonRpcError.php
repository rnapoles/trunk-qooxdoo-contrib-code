<?php
/*
 * qooxdoo - the new era of web development
 *
 * http://qooxdoo.org
 *
 * Copyright:
 *   2006-2007 Derrell Lipman
 *
 * License:
 *   LGPL: http://www.gnu.org/licenses/lgpl.html
 *   EPL: http://www.eclipse.org/org/documents/epl-v10.php
 *   See the LICENSE file in the project's top-level directory for details.
 *
 * Authors:
 *  * Derrell Lipman (derrell)
 *  * Christian Boulanger (cboulanger) 
 */

/**
 * JSON-RPC error origins
 */
define("JsonRpcError_Origin_Server",      1);
define("JsonRpcError_Origin_Application", 2);
define("JsonRpcError_Origin_Transport",   3); // never generated by server
define("JsonRpcError_Origin_Client",      4); // never generated by server


/*
 * JSON-RPC server-generated error codes
 */

/*
 * Error code, value -1: Script Error
 *
 * This error is raised when the service class aborts with an error,
 * either syntax (parsing) errors or runtime exceptions.
 *
 * Although in PHP, it is possible to raise a custom error using the
 * trigger_error() function, that technique is strongly discouraged when
 * using JSON RPC; rather, return an appropriate application-specific error
 * code to the client, with additional descriptive text in the JsonRpcError
 * message.  An error generated with trigger_error() will always yield an
 * error with origin=Server, code=ScriptError which makes it difficult for the
 * client application to ascertain what went wrong.  This is particularly
 * important when the application is to be localized, as it would never
 * display a message directly from the server, but instead display its own
 * message based on the error code.
 */
define("JsonRpcError_ScriptError",    -1);

/**
 * Error code, value 0: Unknown Error
 *
 * The default error code, used only when no specific error code is passed to
 * the JsonRpcError constructor.  This code should generally not be used.
 */
define("JsonRpcError_Unknown",      0);

/**
 * Error code, value 1: Illegal Service
 *
 * The service name contains illegal characters or is otherwise deemed
 * unacceptable to the JSON-RPC server.
 */
define("JsonRpcError_IllegalService",      1);

/**
 * Error code, value 2: Service Not Found
 *
 * The requested service does not exist at the JSON-RPC server.
 */
define("JsonRpcError_ServiceNotFound",     2);

/**
 * Error code, value 3: Class Not Found
 *
 * If the JSON-RPC server divides service methods into subsets (classes), this
 * indicates that the specified class was not found.  This is slightly more
 * detailed than "Method Not Found", but that error would always also be legal
 * (and true) whenever this one is returned.
 */
define("JsonRpcError_ClassNotFound",       3);

/**
 * Error code, value 4: Method Not Found
 *
 * The method specified in the request is not found in the requested service.
 */
define("JsonRpcError_MethodNotFound",      4);

/**
 * Error code, value 5: Parameter Mismatch
 *
 * If a method discovers that the parameters (arguments) provided to it do not
 * match the requisite types for the method's parameters, it should return
 * this error code to indicate so to the caller.
 */
define("JsonRpcError_ParameterMismatch",   5);

/**
 * Error code, value 6: Permission Denied
 *
 * A JSON-RPC service provider can require authentication, and that
 * authentication can be implemented such the method takes authentication
 * parameters, or such that a method or class of methods requires prior
 * authentication.  If the caller has not properly authenticated to use the
 * requested method, this error code is returned.
 */
define("JsonRpcError_PermissionDenied",    6);

define("ScriptTransport_NotInUse",         -1);

/*
 * class JsonRpcError
 *
 * This class allows service methods to easily provide error information for
 * return via JSON-RPC.
 */
class JsonRpcError
{
    var             $json;
    var             $data;
    var             $id;
    var             $scriptTransportId;
    
    function JsonRpcError($json,
                          $origin = JsonRpcError_Origin_Server,
                          $code = JsonRpcError_Unknown,
                          $message = "Unknown error")
    {
        $this->json = $json;
        $this->data = array("origin"  => $origin,
                            "code"    => $code,
                            "message" => $message);

        /* Assume we're not using ScriptTransporrt */
        $this->scriptTransportId = ScriptTransport_NotInUse;
    }
    
    function SetOrigin($origin)
    {
        $this->data["origin"] = $origin;
    }

    function SetError($code, $message)
    {
        $this->data["code"] = $code;
        $this->data["message"] = $message;
    }
    
    function SetId($id)
    {
        $this->id = $id;
    }
    
    function SetScriptTransportId($id)
    {
        $this->scriptTransportId = $id;
    }
    
    function SendAndExit()
    {
        $error = $this;
        $id = $this->id;
        $ret = array("error" => $this->data,
                     "id"    => $id);
        SendReply($this->json->encode($ret), $this->scriptTransportId);
        exit;
    }
}

//=================================================================
// error handling for jsonrpc 
// contributed by Christian Boulanger (info at bibliograph dot org)
//
// The main idea of this code is to keep PHP from messing up the 
// JSONRPC response if a parsing or runtime error occurs, and to 
// allow the client application to handle those errors nicely
//=================================================================

/**
 * switches error handling on or off. Override in global_settings.php
 * default: on
 *
 */
if (! defined("JsonRpcErrorHandling"))
{
    define("JsonRpcErrorHandling",             "on");
}

/**
 * error handling callback function 
 * php4 cannot handle all errors, that's why we have to use a
 * workaround using output buffering (see post by
 * smp at ncoastsoft dot com at
 *   http://www.php.net/manual/en/function.set-error-handler.php
 */ 
function jsonrpc_catch_errors($buffer)
{
    if (ereg("(error</b>:)(.+)(<br)", $buffer, $regs) ) 
    {
        // parse error string from PHP error message 
        $err = preg_replace("/<.*?>/","",$regs[2]);

        // return error formatted as a JSONRPC error response
        return
            '{' .
            '  error:' .
            '  {' .
            '    "origin":' . JsonRpcError_Origin_Server . ',' . 
            '    "code":' .  JsonRpcError_ScriptError . ',' .
            '    "message":"Fatal PHP Error: '. addslashes($err) .
            ' "}' .
            '}';
    } 
    else
    {
        // Buffer does not contain a php error message, so return it
        // unmodified.
        return $buffer;
    }
}


/**
 * jsonrpc error handler to output json error response messages
 */
function jsonRpcErrorHandler($errno, $errstr, $errfile, $errline)
{
    // determine error type
    // todo: remove those which are not captured by set_error_handler()
    switch($errno){
    case E_ERROR:
        $errtype= "Error";
        break;
        
    case E_WARNING:
        $errtype= "Warning";
        break;
        
    case E_PARSE:
        $errtype= "Parse Error";
        break;
        
    case E_NOTICE:
        $errtype= "Notice";
        break;
        
    case E_CORE_ERROR:
        $errtype= "Core Error";
        break;
        
    case E_CORE_WARNING:
        $errtype= "Core Warning";
        break;
        
    case E_COMPILE_ERROR:
        $errtype= "Compile Error";
        break;
        
    case E_COMPILE_WARNING:
        $errtype= "Compile Warning";
        break;
        
    case E_USER_ERROR:
        $errtype= "User Error";
        break;
        
    case E_USER_WARNING:
        $errtype= "User Warning";
        break;
        
    case E_USER_NOTICE:
        $errtype= "User Notice";
        break;
        
    case E_STRICT:
        $errtype= "Strict Notice";
        break;
        
    case E_RECOVERABLE_ERROR:
        $errtype= "Recoverable Error";
        break;
        
    default:
        $errtype= "Unknown error ($errno)";
        break;
    } 
    
    // respect error_reporting level
    $errno = $errno & error_reporting();
    if($errno == 0) return true;
    
    $errmsg =   "PHP $errtype in $errfile, line $errline: $errstr";

    // if not called through jsonrpc request
    global $error;
    if (! is_object($error))
    {
        echo nl2br($errmsg);
        exit(1);
    }
    
    /*
     * get logger
     */
    require_once dirname(__FILE__) . "/../log/Logger.php";
    $logger =& qcl_log_Logger::getInstance();
    
    switch($errno)
    {
      case E_WARNING:
      case E_NOTICE:
          $errmsg = str_replace( array("<br>","<br/>","<br />"),"\n", $errmsg ) ;
          $errmsg = strip_tags($errmsg) ."\n\n";
          $logger->log( $errmsg, "warn" );
          break;
      
      default:
        // return jsonrpc error
        qcl_log_Logger::writeLog(debug_get_backtrace());
        $error->SetError($errno, $errmsg);
        $error->SendAndExit();
    }   
   // never gets here
}

/**
 * main error handling code
 */
if (JsonRpcErrorHandling == "on")
{
    // start buffering to catch errors with handler function
    ob_start("jsonrpc_catch_errors");
  
    // This will not always work, so do some more hacking to comment out
    // uncaught errors.  You'll need to examine the http response to see
    // the uncaught errors!
    ini_set('error_prepend_string', "/*");
    ini_set('error_append_string', "*/");
  
    // error handler function for php jsonrpc
    set_error_handler("jsonRpcErrorHandler"); 
}



?>