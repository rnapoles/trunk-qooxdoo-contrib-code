<?xml version="1.0" encoding='ISO-8859-1'?>

<chapter>
<title>Compiling</title>

<formalpara>
<title>Overview</title>
<para>Mork generates mappers. Technically, this is done by translating ("compiling") mapper files
into class files. The mapper file is supplied by the user, it specifies the mapping of input
streams into Java objects as needed by the respective application. The generated class files are
Java class files, they follow the same rules as class files generated by the Java compiler.
Applications need these class files in their <literal>CLASSPATH</literal> to load and run
mappers.</para></formalpara>

<sect1>
<title>Invocation</title>

<formalpara>
<title>Prerequisites</title>
<para>Before running Mork, make sure to compile you Java source files. Mork checks classes
referenced in mapper files to perform type checking. These classes have to be properly compile
before running Mork: run <literal>javac</literal> on them. </para></formalpara>

<formalpara>
<title>Invocation</title>
<para><literal>"mork" option* file*</literal></para></formalpara>

<para>Mork is similar to <literal>javac</literal>: the user specifies a list of options followed
by a list of files to compile. Mork compiles the file in the given order.</para>

<formalpara>
<title>Example</title>
<para><literal>mork Foo.map</literal> compiles the mapper file, loading it from the current working
directory. A successful compilation results in a class file <literal>Foo.class</literal> (and some
other class files <literal>Foo*.class</literal>).</para></formalpara>

<formalpara>
<title><literal>CLASSPATH</literal></title>
<para>When invoking Mork on a file <literal>Foo.map</literal>, the
<literal>CLASSPATH</literal> has to contain all classes imported in the mapper file. For
example, if <literal>Foo.map</literal> imports a class <literal>mypkg.Bar</literal>, this
class has to be available via the <literal>CLASSPATH</literal> variable. Otherwise, Mork
reports an error, indicating that the class <literal>mypkg.Bar</literal> is not defined.
</para></formalpara>

<formalpara>
<title>Memory consumption</title>
<para>Running Mork on complex mapper files like the Java grammar needs a
substantial amount of memory. If Java runs out of memory (i.e. throws an
<literal>OutOfMemoryError</literal>), use the Java <literal>-Xmx</literal> option in
the launch script to increase the memory available to the virtual machine. Example
<literal>java -Xmx128M de.mlhartme.mork.compiler.Main veryComplex.mork</literal>.
</para></formalpara>

<formalpara>
<title>Command-line arguments vs. mapper files</title>
<para>Mork is controlled by both mapper files command line options, but what setting
is specified where?  Logical settings go into the mapper files, i.e. setting affecting what input
is actually mapped into which object. The same mapper file always results in the same mapping, no
matter what options have been specified on the command line.  Physical settings go into the
command line: where the generated code is stored, or what additional output it generated. Or even
- in future version - optimization settings. </para></formalpara>

</sect1>

<sect1>
<title>Options</title>

<para>Options start with "-" followed by the option name. Options are
case-sensitive. Currently available options:</para>
<itemizedlist>
  <listitem><formalpara><title><literal>-help</literal></title>
    <para>Prints help about invoking Mork.</para>
    </formalpara></listitem>
  <listitem><formalpara><title><literal>-stat</literal></title>
    <para>Prints statistics about mappers to standard output. Use this
    option to see the size of the generated finite automatons and pushdown
    automatons.</para></formalpara></listitem>
  <listitem><formalpara><title><literal>-lst</literal></title>
    <para>Generates listing files. If this option is given, Mork generates
    a listing of each compiled file. The listing includes a
    list of symbols, the mapper's grammar and the generated automatons
    and can get very long. The listing for a file <literal>Foo.map</literal> is written
    to the file <literal>Foo.lst</literal>. Use this option to find grammar conflicts.
    </para></formalpara></listitem>
  <listitem><formalpara><title><literal>-d</literal> directory</title>
    <para>Sets the destination directory for generated class files. If a mapper
    is part of a package, Mork puts the class files in a
    sub directory reflecting the package name, creating directories as needed.</para>
    </formalpara></listitem>
  <listitem><formalpara><title><literal>-verbose</literal></title>
    <para>Issues overall progress information to standard output. If compiling is slow,
    this option can be used to locate which part of the mapper generation is slow.
    </para></formalpara></listitem>
  <listitem><formalpara><title><literal>-verbose:scanning</literal></title>
    <para>Issues scanner progress information. Any token read by the
    scanner is printed to standard output.</para></formalpara></listitem>
  <listitem><formalpara><title><literal>-verbose:parsing</literal></title>
    <para>Issues parser progress information. Any action performed
    by the parser is printed to standard output. Use together with <literal>-lst</literal>,
    this options helps to track down unexpected syntax errors.
    </para></formalpara></listitem>
  <listitem><formalpara><title><literal>-verbose:attribution</literal></title>
    <para>Issues attribution progress information. Any computed attribute
    is printed to standard output.</para></formalpara></listitem>
</itemizedlist>

</sect1>

<sect1>
<title>Re-compiling</title>

<para>When do you have to re-run Mork? Nothing surprising here, the rules
are similar to Java files and the Java compiler. A compiled mapper depends
on its mapper file and the signature of the referenced constructors. Thus,
re-compile a mapper if the mapper file (or the referenced syntax file) or
the signature of at least on of the referenced constructors has changed. Note
that changing a constructor without affecting the signature does not require
a re-compile.</para>

<para>Class file analyzer tools see constructor references as normal Java call,
no reflection is used. Thus, it is possible to use a to find class file dependencies.
</para>

</sect1>

<sect1>
<title>Ant</title>

<para>You might want to use Jakarta Ant to build your application. Here is an
how to invoke Mork on the file <literal>foo/Mapper.map</literal>.</para>

<programlisting>
<![CDATA[<target name="mork">
<java classname="de.mlhartme.mork.compiler.Main"
      fork="yes"
      failonerror="yes"
      classpathref="classpath">
  <arg value="-d"/>
  <arg value="${build.classes}"/>
  <arg value="foo/Mapper.map"/>
</java>
</target>
]]></programlisting>
</sect1>

</chapter>
