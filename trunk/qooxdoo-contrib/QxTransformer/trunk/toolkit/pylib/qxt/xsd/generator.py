from xml.sax.saxutils import XMLGenerator
from xml.sax.xmlreader import AttributesNSImpl


XSD_NS = 'http://www.w3.org/2001/XMLSchema'
QX_NS = 'http://www.qxtransformer.org/qooxdoo/0.8'
QXT_NS = 'http://www.qxtransformer.org/qooxdoo/0.4'


class SchemaGenerator(object):
    """
    This class generates XSD schema based on class description from qooxdoo API.
    Constructor takes dictinary with class description, generated by qxt.xsd.utils.ApiDataParser.
    
    """
    def __init__(self, classInfoDict):
        self.__classInfoDict = classInfoDict
    
    
    def generate(self, fileName):
        """
        Generates XSD based on given classes definitions. Writes it to specified fileName.
        """
        #TODO make proper error handling if something wrong with file.
        self.__output = open(fileName,"w")
        self.__doc = XMLGenerator(self.__output, "utf-8") 
        self.__doc.startDocument()
        
        self.__start_schema()
        
        # generate attibute groups
        self.__generate_attribute_groups()
        
        # generate group of references
        
        # generate allGroup element
        self.__generate_all_group()
        
        # generate elements
        self.__generate_elements()
        
        # generate top level elements
        self.__generate_top_elements()
        
        
        self.__end_schema()
        
        self.__doc.endDocument()
        self.__output.close()


    def __start_schema(self):
        """Generates schema header."""
        
        self.__doc.startPrefixMapping(u'xsd', XSD_NS)
        self.__doc.startPrefixMapping(u'qx', QX_NS)
        self.__doc.startPrefixMapping(u'qxt', QXT_NS)
        
        shemaattr = AttributesNSImpl({
            (None, 'targetNamespace') : "http://www.qxtransformer.org/qooxdoo/0.8",
            (None, 'elementFormDefault') : 'qualified',
            (None, 'attributeFormDefault') : 'unqualified'
        }, {})
        
        self.__doc.startElementNS((XSD_NS, u'schema'), u'xsd:schema', shemaattr)
        
    def __end_schema(self):
        """Generated closing tags for schema."""
        
        self.__doc.endElementNS((XSD_NS, u'schema'), u'xsd:schema')
        self.__doc.endPrefixMapping(u'xsd')
    
    def __generate_attribute_groups(self):
        """Geneartes all groups for API data.
        Iterates over al classes definitions.
        """
        for className, classInfo in self.__classInfoDict.iteritems():
            self.__generate_attribute_group(className, classInfo)
    
    def __generate_attribute_group(self, className, classInfo):
        """Generate an attribute group based on given classInfo for each class.
        Includes class property in group if it's not overriden from base class 
        (in other case it will be added for base class).
        """
        
        self.__doc.startElementNS((XSD_NS, u'attributeGroup'), u'xsd:attributeGroup', AttributesNSImpl({
            (None, 'name') : className
        }, {}))
        
        #generate attrubute group only if class has any properties
        if classInfo.has_key('properties'):
            properties = classInfo['properties']
            for propName, prop in properties.iteritems():
                #include property only if it's not overriden from base class
                if not prop.get('overriddenFrom'):
                    self.__doc.startElementNS((XSD_NS, u'attribute'), u'xsd:attribute', AttributesNSImpl({
                        (None, 'name') : propName
                    }, {}))
                    
                    self.__doc.startElementNS((XSD_NS, u'annotation'), u'xsd:annotation', AttributesNSImpl({},{}))
                    self.__doc.startElementNS((XSD_NS, u'documentation'), u'xsd:documentation', AttributesNSImpl({},{}))
                
                    self.__doc.characters(prop.get('info',''))
                
                    self.__doc.endElementNS((XSD_NS, u'documentation'), u'xsd:documentation')
                    self.__doc.endElementNS((XSD_NS, u'annotation'), u'xsd:annotation')
                    self.__doc.endElementNS((XSD_NS, u'attribute'), u'xsd:attribute')
        
        self.__doc.endElementNS((XSD_NS, u'attributeGroup'), u'xsd:attributeGroup')
        
    def __generate_elements(self):
        """Generated all elements for given API data.
        Iterates over all definitions."""
        
        for className, classInfo in self.__classInfoDict.iteritems():
            
            tagName = self.__parse_tag_name(classInfo.get('tagName'))
            
            # generate tag only if tag name has namespace (tags without namespaces in config 
            # are base tags only for inheritance inside config file)
            if tagName and tagName[0]:
                 inheritance_chain = []
                 self.__fill_inheritance_chain(inheritance_chain, className)
                 
                 self.__generate_element(tagName, className, classInfo, inheritance_chain, [('qx','allGroup')])
    
    def __generate_element(self, tagName, className, classInfo, attributeGroups, elementGroup):
        """Generates an definition of XSD element.
        
        @param   tagName     tuple produced by __parse_tag_name
        @param   className   name of widget class
        @param   classInfo   dictionary with class information
        @param   attributeGroups   array with all attribute groups which this class includes (simply all inheritance chain)
        @param   elementGroup   array with all allowed child elements
        """
        
        self.__doc.startElementNS((XSD_NS, u'element'), u'xsd:element', AttributesNSImpl({(None, 'name') : tagName[1]},{}))
        
        self.__doc.startElementNS((XSD_NS, u'annotation'), u'xsd:annotation', AttributesNSImpl({},{}))
        self.__doc.startElementNS((XSD_NS, u'documentation'), u'xsd:documentation', AttributesNSImpl({},{}))
        
        self.__doc.characters(classInfo.get('info',''))
        
        self.__doc.endElementNS((XSD_NS, u'documentation'), u'xsd:documentation')
        self.__doc.endElementNS((XSD_NS, u'annotation'), u'xsd:annotation')
        
        self.__doc.startElementNS((XSD_NS, u'complexType'), u'xsd:complexType', AttributesNSImpl({},{}))
        
        #generate references for allowed child elements
        self.__doc.startElementNS((XSD_NS, u'sequence'), u'xsd:sequence', AttributesNSImpl({},{}))
        
        for group in elementGroup:
            self.__doc.startElementNS((XSD_NS, u'group'), u'xsd:group', AttributesNSImpl({
                (None, 'ref'): ":".join(group)
            },{}))
            self.__doc.endElementNS((XSD_NS, u'group'), u'xsd:group')
        
        self.__doc.endElementNS((XSD_NS, u'sequence'), u'xsd:sequence')
        
        #generate attribute group
        for attrGroupName in attributeGroups:
            #TODO fix namespace of the generated group
            self.__doc.startElementNS((XSD_NS, u'attributeGroup'), u'xsd:attributeGroup', AttributesNSImpl({ 
                 (None, 'ref') : "qx:%s" %attrGroupName
             },{}))
             
            self.__doc.endElementNS((XSD_NS, u'attributeGroup'), u'xsd:attributeGroup')
             
        self.__doc.endElementNS((XSD_NS, u'complexType'), u'xsd:complexType')
        self.__doc.endElementNS((XSD_NS, u'element'), u'xsd:element')
    
    def __generate_group(self, name, tagNames):
        """Generates group with references to allowed element."""
        
        self.__doc.startElementNS((XSD_NS, u'group'), u'xsd:group', AttributesNSImpl({ 
                (None, 'name') : name
            },{}))

        self.__doc.startElementNS((XSD_NS, u'choice'), u'xsd:choice', AttributesNSImpl({},{}))
        
        for tagName in tagNames:
            self.__doc.startElementNS((XSD_NS, u'element'), u'xsd:element', AttributesNSImpl({ 
                     (None, 'ref') : ':'.join(tagName),
                     (None, 'minOccurs') : '0',
                     (None, 'maxOccurs') : 'unbounded'
                 },{}))
            self.__doc.endElementNS((XSD_NS, u'element'), u'xsd:element')
        
        self.__doc.endElementNS((XSD_NS, u'choice'), u'xsd:choice')
        self.__doc.endElementNS((XSD_NS, u'group'), u'xsd:group')
    
    def __generate_all_group(self):
        """Genrates group with name 'allGroup' which includes all tags from XSD."""
        
        # getting all tags from class info (only with defined namespaces)
        groupTags = []
        for className, classInfo in self.__classInfoDict.iteritems():
            tagName = self.__parse_tag_name(classInfo.get('tagName'))
            # tag with defined namespace
            if tagName and tagName[0]:
                groupTags.append(tagName)
                
        # generate group
        self.__generate_group('allGroup', groupTags)
    
    def __generate_top_elements(self):
        """Generates a set of predefined top level elements."""
        
        self.__generate_element((None, 'application'), None, {}, [], [('qx','allGroup')])
    
    def __fill_inheritance_chain(self, chain, className):
        """Fills inheritance chain for given className. 
        Chain will contain base class, base class of base class, ...
        Uses recursion.
        """
        
        chain.append(className)
        superClass = self.__classInfoDict[className].get('superClass')
        
        if superClass:
            self.__fill_inheritance_chain(chain,superClass)
    
    def __parse_tag_name(self, tagName):
        """Parses tag name and returns it as tuple."""
        
        if not tagName:
            return None
        
        parts = tagName.split(':')
        
        if len(parts)==2:
            return (parts[0],parts[1])
        elif len(parts)==1:
            return (None,tagName)
        else:
            return None


        